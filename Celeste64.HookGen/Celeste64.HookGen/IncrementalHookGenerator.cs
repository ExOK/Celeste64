using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Celeste64.HookGen;

[Generator]
public class IncrementalHookGenerator : IIncrementalGenerator
{
	private const string OrigNamespace = "Celeste64";
	private const string OnNamespace = $"On.{OrigNamespace}";
	
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				static (node, _) =>
				{
					return node is ClassDeclarationSyntax;
				}, 
				static (ctx, _) =>
				{
					return (ClassDeclarationSyntax)ctx.Node;
				})
			.Where(static type =>
			{
				if (type.Parent is not BaseNamespaceDeclarationSyntax ns)
					return false;
				if (ns.Name is not SimpleNameSyntax nsName) 
					return false;

				return nsName.Identifier.Text == OrigNamespace;
			});
		
		context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
			static (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
	}
	
	private static void GenerateCode(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classDeclarations)
	{
		StringBuilder code = new();
		code.AppendLine("// <auto-generated/>");
		code.AppendLine($"namespace {OnNamespace};");
		code.AppendLine();
		
		foreach (var classDecl in classDeclarations)
		{
			var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol)
				continue;
			
			var className = classDecl.Identifier.Text;
			
			code.AppendLine($"public static class {className}");
			code.AppendLine("{");
			
			var methods = classSymbol
				.GetMembers()
				.OfType<IMethodSymbol>()
				.Concat(classSymbol.StaticConstructors);
			foreach (var method in methods)
			{
				var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				var parameters = method.Parameters
					.Select(param => $"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {param.Name}")
					.ToArray();
				var methodName = method.Name switch
				{
					".ctor" => "ctor",
					".cctor" => "cctor",
					_ => method.Name,
				};
				
				if (method.IsStatic)
					code.AppendLine($"    public delegate {returnType} orig_{methodName}({string.Join(", ", parameters)})");
				else if (parameters.Length == 0)
					code.AppendLine($"    public delegate {returnType} orig_{methodName}({classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} self)");
				else
					code.AppendLine($"    public delegate {returnType} orig_{methodName}({classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} self, {string.Join(", ", parameters)})");
			}
			
			code.AppendLine("}");
			code.AppendLine();
		}
		
		context.AddSource("HookGen.g.cs", code.ToString());
	}
}