using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Celeste64.HookGen;

[Generator]
public class IncrementalHookGenerator : IIncrementalGenerator
{
	private const string Indent = "    ";

	private const string OrigNamespace = "Celeste64";
	private const string OnNamespace = $"On.{OrigNamespace}";

	private const string HookGenTargetAttribute = "global::Celeste64.Mod.InternalHookGenTargetAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Get all classes from the 'Celeste64' namespace
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				static (node, _) => node is ClassDeclarationSyntax,
				static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
			.Where(static type =>
			{
				if (type.Parent is not BaseNamespaceDeclarationSyntax ns)
					return false;
				if (ns.Name is not SimpleNameSyntax nsName)
					return false;

				return nsName.Identifier.Text == OrigNamespace;
			});

		context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
			static (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
	}

	private static void GenerateCode(SourceProductionContext context, Compilation compilation,
		ImmutableArray<ClassDeclarationSyntax> classDeclarations)
	{
		StringBuilder code = new();
		code.AppendLine("// <auto-generated/>");
		code.AppendLine($"namespace {OnNamespace};");
		code.AppendLine();

		foreach (var classDecl in classDeclarations)
		{
			var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol)
				continue;

			// We can't hook generic types
			// We don't want to hook non-public types
			if (classSymbol.IsGenericType || classSymbol.DeclaredAccessibility != Accessibility.Public)
				continue;

			var className = classDecl.Identifier.Text;

			code.AppendLine($"public static class {className}");
			code.AppendLine("{");

			var methods = classSymbol
				.GetMembers()
				.OfType<IMethodSymbol>()
				.Concat(classSymbol.StaticConstructors)
				.ToArray();

			List<(string Name, ImmutableArray<IParameterSymbol> Params)> emittedSymbols = [];

			foreach (var method in methods)
			{
				if (
					// We can't hook generic methods
					method.IsGenericMethod ||
					// We don't want to hook non-public methods
					method.DeclaredAccessibility != Accessibility.Public ||
					// There are some duplicates for, so check if this exact signature was already generated
					emittedSymbols.Contains((method.Name, method.Parameters)))
				{
					continue;
				}

				emittedSymbols.Add((method.Name, method.Parameters));

				var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				var parameters = method.Parameters
					.Select(param => $"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {param.Name}")
					.ToArray();
				var methodName = method.Name switch
				{
					".ctor" => "ctor",
					".cctor" => "cctor",
					_ => method.Name,
				};

				// Generate signature with parameters, if the method is overloaded
				// NOTE: If they have the same parameters, they are a duplicate and not an overload.
				var isOverloaded = methods.Any(m => m.Name == method.Name && !m.Parameters.SequenceEqual(method.Parameters));
				if (isOverloaded)
					methodName += $"__{string.Join("__", method.Parameters.Select(param =>
						param.Type
							.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)
							.Replace("?", "_nullable") // Use 'int_nullable' instead of 'int?'
							.Replace("<", "_").Replace(">", "")))}"; // Use 'List_int' instead of 'List<int>'

				// NOTE: Only public methods can be hooked anyway
				var bindingFlags = method.IsStatic
					? "System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public"
					: "System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public";

				// orig_ delegate
				if (method.IsStatic)
					code.AppendLine($"{Indent}public delegate {returnType} orig_{methodName}({string.Join(", ", parameters)});");
				else if (parameters.Length == 0)
					code.AppendLine(
						$"{Indent}public delegate {returnType} orig_{methodName}({classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} self);");
				else
					code.AppendLine(
						$"{Indent}public delegate {returnType} orig_{methodName}({classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} self, {string.Join(", ", parameters)});");

				// Hook attribute
				code.AppendLine(
					$"{Indent}public sealed class {methodName}Attribute : {HookGenTargetAttribute}");
				code.AppendLine($"{Indent}{{");
				code.AppendLine($"{Indent}{Indent}public {methodName}Attribute()");
				code.AppendLine($"{Indent}{Indent}{{");
				code.AppendLine($"{Indent}{Indent}{Indent}TargetType = \"{classSymbol.ToTypeString()}\";");
				code.AppendLine($"{Indent}{Indent}{Indent}TargetMemberName = \"{method.Name}\";");
				if (isOverloaded)
				{
					var paramsString = string.Join(", ", method.Parameters.Select(param =>
						$"\"{param.Type.ToTypeString()}\""));
					code.AppendLine($"{Indent}{Indent}{Indent}TargetParameters = [{paramsString}];");
				}

				code.AppendLine($"{Indent}{Indent}}}");
				code.AppendLine($"{Indent}}}");

				code.AppendLine();
			}

			code.AppendLine("}");
			code.AppendLine();
		}

		context.AddSource("HookGen.g.cs", code.ToString());
	}
}

internal static class TypeSymbolExtensions
{
	/// <summary>
	/// Converts a generic type into a string which can be parsed by <code>Assembly.GetType</code>
	/// </summary>
	public static string ToTypeString(this ITypeSymbol typeSymbol)
	{
		var sb = new StringBuilder();
		AppendTypeString(typeSymbol, sb);
		return sb.ToString();
	}

	private static readonly SymbolDisplayFormat symbolFormat =
		new(
			globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,
			typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
			genericsOptions: SymbolDisplayGenericsOptions.None,
			miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);

	private static void AppendTypeString(ITypeSymbol typeSymbol, StringBuilder sb)
	{
		if (typeSymbol is INamedTypeSymbol namedType)
		{
			sb.Append(namedType.ToDisplayString(symbolFormat));
			if (namedType.TypeArguments.Length <= 0) return;

			sb.Append($"`{namedType.TypeArguments.Length}[");
			for (int i = 0; i < namedType.TypeArguments.Length; i++)
			{
				if (i > 0)
					sb.Append(',');
				AppendTypeString(namedType.TypeArguments[i], sb);
			}

			sb.Append(']');
		}
		else
		{
			sb.Append(typeSymbol.MetadataName);
		}
	}
}