using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Celeste64.HookGen;

[Generator]
public class IncrementalHookGenerator : IIncrementalGenerator
{
	private const string OrigNamespace = "Celeste64";
	private const string OnNamespace = $"On.{OrigNamespace}";
	
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				static (node, _) =>
				{
					Console.WriteLine($"Node: {node}");
					return node is ClassDeclarationSyntax;
				}, 
				static (ctx, _) =>
				{
					Console.WriteLine($"Ctx: {ctx}");
					return (ClassDeclarationSyntax)ctx.Node;
				})
			.Where(static type =>
			{
				Console.WriteLine($"Type: |{type}|");
				if (type.Parent is not BaseNamespaceDeclarationSyntax ns)
					return false;
				Console.WriteLine($"NS: |{ns}|");
				if (ns.Name is not SimpleNameSyntax nsName) 
					return false;

				Console.WriteLine($"Namespace: |{nsName.Identifier.Text}|");
				return nsName.Identifier.Text == OrigNamespace;
			});
		
		context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
			static (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
	}
	
	private static void GenerateCode(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classDeclarations)
	{
		StringBuilder code = new();
		code.AppendLine("// <auto-generated/>");
		code.AppendLine("using System.Reflection;");
		code.AppendLine();
		code.AppendLine($"namespace {OnNamespace};");
		code.AppendLine();
		
		foreach (var classDecl in classDeclarations)
		{
			var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol)
				continue;
			
			var className = classDecl.Identifier.Text;
			
			code.AppendLine($"public static class {className}");
			code.AppendLine("{");
			
			var methods = classSymbol
				.GetMembers()
				.OfType<IMethodSymbol>();
			foreach (var method in methods)
			{
				var parameters = method.Parameters
					.Select(param => $"{param.Type} {param.Name}")
					.ToArray();
				
				if (method.IsStatic)
					code.AppendLine($"    public delegate {method.ReturnType.Name} orig_{method.Name}({string.Join(", ", parameters)})");
				else if (parameters.Length == 0)
					code.AppendLine($"    public delegate {method.ReturnType.Name} orig_{method.Name}({className} self)");
				else
					code.AppendLine($"    public delegate {method.ReturnType.Name} orig_{method.Name}({className} self, {string.Join(", ", parameters)})");
			}
				
			
			code.AppendLine("}");
			code.AppendLine();
		}
		
		context.AddSource("HookGen.g.cs", code.ToString());
	}
}