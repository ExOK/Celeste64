using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Celeste64.HookGen;

[Generator]
public class IncrementalHookGenerator : IIncrementalGenerator
{
	private const string OrigNamespace = "Celeste64";
	private const string OnNamespace = $"On.{OrigNamespace}";
	
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				static (node, _) => node is ClassDeclarationSyntax, 
				static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
			.Where(static type =>
			{
				if (type.Parent is not BaseNamespaceDeclarationSyntax ns)
					return false;
				if (ns.Name is not SimpleNameSyntax nsName) 
					return false;

				return nsName.Identifier.Text == OrigNamespace;
			});
		
		context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
			static (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
	}
	
	private static void GenerateCode(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classDeclarations)
	{
		StringBuilder code = new();
		code.AppendLine("// <auto-generated/>");
		code.AppendLine($"namespace {OnNamespace};");
		code.AppendLine();
		
		foreach (var classDecl in classDeclarations)
		{
			var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol)
				continue;
			
			// We can't hook generic types
			// We don't want to hook non-public types
			if (classSymbol.IsGenericType || classSymbol.DeclaredAccessibility != Accessibility.Public)
				continue;
			
			var className = classDecl.Identifier.Text;
			
			code.AppendLine($"public static class {className}");
			code.AppendLine("{");
			
			var methods = classSymbol
				.GetMembers()
				.OfType<IMethodSymbol>()
				.Concat(classSymbol.StaticConstructors)
				.ToArray();
			
			List<(string Name, ImmutableArray<IParameterSymbol> Params)> emittedSymbols = [];
				
			foreach (var method in methods)
			{
				if (
					// We can't hook generic methods
					method.IsGenericMethod ||
					// We don't want to hook non-public methods
					method.DeclaredAccessibility != Accessibility.Public ||
					// There are some duplicates for, so check if this exact signature was already generated
					emittedSymbols.Contains((method.Name, method.Parameters)))
				{
					continue;
				}
				emittedSymbols.Add((method.Name, method.Parameters));
				
				var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				var parameters = method.Parameters
					.Select(param => $"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {param.Name}")
					.ToArray();
				var methodName = method.Name switch
				{
					".ctor" => "ctor",
					".cctor" => "cctor",
					_ => method.Name,
				};
				
				// Generate signature with parameters, if the method is overloaded
				// NOTE: If they have the same parameters, they are a duplicate and not an overload.
				if (methods.Any(m => m.Name == method.Name && !m.Parameters.SequenceEqual(method.Parameters)))
					methodName += $"__{string.Join("__", method.Parameters.Select(param =>
						param.Type
							.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)
							.Replace("?", "_nullable") // Use 'intNullable' instead of 'int?'
							.Replace("<", "_").Replace(">", "")))}"; // Use 'List_int' instead of 'List<int>'
				
				if (method.IsStatic)
					code.AppendLine($"    public delegate {returnType} orig_{methodName}({string.Join(", ", parameters)});");
				else if (parameters.Length == 0)
					code.AppendLine($"    public delegate {returnType} orig_{methodName}({classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} self);");
				else
					code.AppendLine($"    public delegate {returnType} orig_{methodName}({classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} self, {string.Join(", ", parameters)});");
				
				// NOTE: Only public methods can be hooked anyway
				var bindingFlags = method.IsStatic 
					? "System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public" 
					: "System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public";
				
				code.AppendLine($"""    private static readonly System.Reflection.MethodInfo info_{methodName} = typeof({classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}).GetMethod("{method.Name}", {bindingFlags});""");
				code.AppendLine();
			}
			
			code.AppendLine("}");
			code.AppendLine();
		}
		
		context.AddSource("HookGen.g.cs", code.ToString());
	}
}